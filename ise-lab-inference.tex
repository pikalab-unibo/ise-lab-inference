%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ISE Lab -- Topic
% Giovanni Ciatto
% Alma Mater Studiorum - Universit√† di Bologna
% mailto:giovanni.ciatto@unibo.it
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\documentclass[handout]{beamer}\mode<handout>{\usetheme{default}}
%
\documentclass[presentation]{beamer}\mode<presentation>{\usetheme{AMSBolognaFC}}
%\documentclass[handout]{beamer}\mode<handout>{\usetheme{AMSBolognaFC}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{ise-lab-common}
\usepackage{ise-lab-inference}
% version
\newcommand{\versionmajor}{0}
\newcommand{\versionminor}{2}
\newcommand{\versionpatch}{0-dev}
\newcommand{\version}{\versionmajor.\versionminor.\versionpatch}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title[\currentLab{} -- Inference]{Automatic Inference on Horn Clauses}
%
\subtitle{\courseName{} / Module \moduleN{} (\courseAcronym)}
%
\author[\sspeaker{\gcShort}]{\speaker{\gcFull} \\ \gcEmail}
%
\institute[\disiShort, \uniboShort]{\disi{} (\disiShort)\\\unibo}
%
\date[A.Y. \academicYear{} (v.\ \version)]{Academic Year \academicYear{}\\(version \version)}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%/////////
\frame{\titlepage}
%/////////

%%===============================================================================
\section*{Outline}
%%===============================================================================
%
%%/////////
\frame[c]{\tableofcontents[hideallsubsections]}
%%/////////

%===============================================================================
\section{Premises}
%===============================================================================

\begin{frame}{Lecture Goals}
    \begin{itemize}
        \item Understand basic notions concerning the \alert{manipulation} of Horn clauses
        %
        \begin{itemize}
            \item substitutions
            \item unification and (most general) unifiers
        \end{itemize}

        \vfill

        \item Understand how these notions can be exploited for \alert{automated inference}
        %
        \begin{itemize}
            \item using the SL\ccite{Robinson1965} resolution principle\ldots
            \item \ldots as suggested by \cite{KowVan1970} (SLD)
        \end{itemize}

        \vfill

        \item Understand the notion of \alert{proof tree}
        %
        \begin{itemize}
            \item and the different possible strategies for its \alert{exploration}
        \end{itemize}
    \end{itemize}
\end{frame}

%===============================================================================
\section{Substitutions and their Application to Logic Formul\ae{}}
%===============================================================================

\begin{frame}{Overview}
    \begin{itemize}
        \item[$\checkmark$] Three main ingredients:
        %
        \begin{description}\small
            \item[terms] --- for representing entities
            \item[predicates] --- for representing statements about entities
            \item[clauses] --- for representing properties of entities or relations among them
        \end{description}

        \vfill

        \item[$\checkmark$] Many ways of representing knowledge through them:
        %
        \begin{description}\small
            \item[extensional vs. intensional] $\approx$ explicitly vs. implicitly
            \item[propositional vs. relational] $\approx$ in tabular form vs. as a graph
        \end{description}

        \vfill

        \item One powerful tool:
        %
        \begin{description}\small
            \item[resolution] --- allowing for \alert{intensional} representations, programming, reasoning, \ldots
        \end{description}

        \vfill

        \item[$\rightarrow$] Two fundamental mechanisms for manipulating knowledge:
        %
        \begin{description}\small
            \item[substitution application] $\approx$ rewriting a formula by assigning variables
            \item[most general unifier] $\approx$ computing the substitution making 2 formul\ae{} equal
        \end{description}
    \end{itemize}
\end{frame}

\subsection{Substitutions}

\begin{frame}[allowframebreaks]{Substitutions}
    \begin{block}{Purpose}\centering
        Denoting variables assignemnts
    \end{block}
    %
    \begin{block}{Informal definition}
        A (possibly \emph{empty}) set of \alert{variable--term} pairs
    \end{block}
    %
    \begin{alertblock}{Formal syntax\hfill\textbf{\footnotesize(same syntactic notation as in \cite{lectures:ise-kr})}}
        \begin{center}
            $\begin{array}{rcl}
                \meta{Substitution} & := & \terminal{\varnothing} \mid \terminal{\{} \meta{Assignemnts} \terminal{\}}
                \\
                \meta{Assignments} & := & \meta{Assignment} \mid \meta{Assignments} \terminal{,} \meta{Assignments}
                \\
                \meta{Assignment} & := & \meta{Variable} \terminal{\mapsto} \meta{Term}
                \\
                \meta{Term} & := & \text{see lecture \cite{lectures:ise-kr}}
				\\
                \meta{Variable} & := & \text{see lecture \cite{lectures:ise-kr}}
			\end{array}$
        \end{center}
    \end{alertblock}

    \begin{exampleblock}{Examples}
        \begin{description}
            \item[$\varnothing$] --- the empty substitution (no variable to be assigned)
            \item[$\{ \variable{X} \mapsto \functor{a} \}$] --- the substitution assigning variable $\variable{X}$ with the constant $\functor{a}$
            \item[$\{ \variable{X} \mapsto \functor{a}, \variable{Y} \mapsto \functor{b} \}$] --- the substitution assigning 
            %
			\begin{itemize}
				\item variable $\variable{X}$ with the constant $\functor{a}$, and
				\item variable $\variable{Y}$ with the constant $\functor{b}$ 
			\end{itemize} 
        \end{description}
    \end{exampleblock}
\end{frame}

\subsection{Substitution Application}

\begin{frame}[allowframebreaks]{Applying Substitutions to Logic Formul\ae{}}
    \begin{block}{Purpose}\centering
        Actually assigning some formula's variables with some values, as denoted by some given substitution
    \end{block}
    %
    \begin{block}{Informal definition}
        The operation by which 
		%
		\begin{enumerate}
			\item a formula (i.e. a term, a predicate, or a Horn cluase) \ldots
			\item \ldots is \alert{rewritten} \ldots
			\item \ldots by \alert{replacing} all variables therein contained \ldots
			\item \ldots with some other \alert{terms}, as prescribed by a given \alert{substitution}
		\end{enumerate}
    \end{block}
	%
    \begin{block}{Notation}
        \begin{itemize}
			\item We denote by 
			%
			\[ \Phi / \sigma \qquad \equiv \Phi'\]
			%
			the operation of applying a substitution $\sigma$ to some formula $\Phi$
			%
			\begin{itemize}
				\item hence producing a new formula $\Phi$
			\end{itemize}

			\item Notice that:
			%
			\begin{itemize}
				\item $(\cdot / \cdot)$ is a function mapping formul\ae{} and substitutions to other formul\ae{}
				\item we denote substitutions by lowercase greek letters such as $\sigma$, $\rho$, etc.
				\item we denote formul\ae{} by uppercase greek letters such as $\Phi$, $\Psi$, etc.
			\end{itemize} 
		\end{itemize}
    \end{block}
    %
    \begin{alertblock}{Formal definition}
		Let $\Phi, \Psi, \Psi', \Psi_1, \ldots, \Psi_n$ be logic formul\ae{} (i.e. terms, predicates, or a Horn cluases) of any sort, 
		%
		let $\predication{p}$ be a $n$-ary predication, let $\functor{f}$ be a $m$-ary functor, let $\functor{k}$ be a constant, let $t$ be a term of any sort,
		%
		and let $\sigma$ be a (possibly empty) substitution;
		%
		then
		
		$$\Phi / \sigma = \begin{cases}
			\Psi / \sigma \Leftarrow \Psi' / \sigma & \text{if} ~ \Phi \equiv \Psi \Leftarrow \Psi'
			\\
			\Psi / \sigma \wedge \Psi' / \sigma & \text{if} ~ \Phi \equiv \Psi \wedge \Psi'
			\\
			\predication{p}(\Psi_1 / \sigma, \ldots, \Psi_n / \sigma) & \text{if} ~ \Phi \equiv \predication{p}(\psi_1, \ldots, \psi_n)
			\\
			\functor{f}(\Psi_1 / \sigma, \ldots, \Psi_m / \sigma) & \text{if} ~ \Phi \equiv \functor{f}(\psi_1, \ldots, \psi_m)
			\\
			\functor{k} & \text{if} ~ \Phi \equiv \functor{k}
			\\
			t & \text{if} ~ \Phi \equiv \variable{X} ~ \text{and} ~ (\variable{X} \mapsto t) \in \sigma
			\\
			\variable{X} & \text{if} ~ \Phi \equiv \variable{X} ~ \text{and} ~ (\variable{X} \mapsto t) \not\in \sigma
		\end{cases}$$
    \end{alertblock}

    \begin{exampleblock}{Examples}
        \begin{itemize}
            \item[] \alert{$\functor{f}(\variable{X}) \ /\  \varnothing$} $\equiv$ $\functor{f}(\variable{X})$
            %
			\begin{itemize}
				\item applying empty substitutions to formul\ae{} has no effect
			\end{itemize} 

			\item[] \alert{$\functor{k} \ /\  \sigma$} $\equiv$ $\functor{k}$
            %
			\begin{itemize}
				\item applying substitutions to constants has no effect
			\end{itemize} 

			\item[] \alert{$\predication{p}(X, \functor{f}(Y)) \ /\  \{ X \mapsto \functor{a}, Y \mapsto \functor{b} \}$} $\equiv$ $\predication{p}(\functor{a}, \functor{f}(\functor{b}))$
            %
			\begin{itemize}
				\item applying substitutions to formul\ae{} replaces the variables therein contained\ldots
			\end{itemize} 

			\item[] \alert{$\predication{p}(X, \functor{f}(Y)) \ /\  \{ X \mapsto \functor{a} \}$} $\equiv$ $\predication{p}(\functor{a}, \functor{f}(Y))$
            %
			\begin{itemize}
				\item \ldots provided that the variable is contained in the substitution\ldots
			\end{itemize} 

			\item[] \alert{$\predication{p}(X, \functor{f}(Y)) \ /\  \{ X \mapsto \functor{a}, Z \mapsto \functor{b} \}$} $\equiv$ $\predication{p}(\functor{a}, \functor{f}(Y))$
            %
			\begin{itemize}
				\item \ldots and in the formula
			\end{itemize} 
        \end{itemize}
    \end{exampleblock}
\end{frame}

\subsection{Refreshing Formul\ae{}}

\begin{frame}[allowframebreaks]{Refreshing Formul\ae{}}
    \begin{block}{Purpose}
        Allowing a formula to be re-used in different contexts, avoiding undesired variable assignments 
		%
		\begin{itemize}
			\item this is not relevant in theory, but very important in practice
		\end{itemize}
    \end{block}
    %
    \begin{block}{Informal definition}
        A formula is \alert{refreshed} by 
		%
		\begin{itemize}
			\item \emph{consistently} replacing each variable therein contained
			\item with some \emph{bare new}\footnote{never used before} variable of similar name 
		\end{itemize}
    \end{block}
    %
    \begin{alertblock}{Formal definition}
		Let 
		%
		\begin{itemize}
			\item \alert{$\Phi$} be a formula (i.e. term, predicate, or Horn cluase) of any sort 
			\item \alert{$\rho = \{ \variable{X} \mapsto \hat{\variable{X}} \mid \forall \variable{X} \in \Phi \}$} be the refreshing substitution for $\Phi$
			%
			\begin{itemize}\small
				\item where $\hat{\variable{X}}$ is a variable which has \alert{never been used before}
			\end{itemize} 
		\end{itemize}
		%
		then we define ``refreshing $\Phi$'' as the operation of applying $\rho$ to $\Phi$:hat
		%
		\begin{center}
			$ \text{refresh}(\Phi) = \alert{\Phi / \rho} $
		\end{center}
    \end{alertblock}

    \begin{exampleblock}{Examples}
        \begin{multicols}{2}\small
			\begin{itemize}
				\item $\text{refresh}(\alert{\functor{f}(\variable{X}, \functor{g}(\variable{X}))})$ 
				\item $\text{refresh}(\alert{\predication{p}(\variable{X}, \functor{f}(\variable{Y}), \functor{g}(\variable{X}))})$ 
				\item $\text{refresh}(\alert{\predication{list}([\variable{H} \mid \variable{T} ])) \Leftarrow \predication{list}(\variable{T})})$ 
				
				\item[$=$] $\functor{f}(\hat{\variable{X}}, \functor{g}(\hat{\variable{X}}))$
				\item[$=$] $\predication{p}(\hat{\variable{X}}, \functor{f}(\hat{\variable{Y}}), \functor{g}(\hat{\variable{X}}))$
				\item[$=$] $\predication{list}([\hat{\variable{H}} \mid \hat{\variable{T} ]})) \Leftarrow \predication{list}(\hat{\variable{T}})$
			\end{itemize}
		\end{multicols}
    \end{exampleblock}
\end{frame}

%===============================================================================
\section{Unification}
%===============================================================================

\begin{frame}{Overview}
    \begin{itemize}
        \item[$\checkmark$] Three main ingredients:
        %
        \begin{description}\small
            \item[terms] --- for representing entities
            \item[predicates] --- for representing statements about entities
            \item[clauses] --- for representing properties of entities or relations among them
        \end{description}

        \vfill

        \item[$\checkmark$] Many ways of representing knowledge through them:
        %
        \begin{description}\small
            \item[extensional vs. intensional] $\approx$ explicitly vs. implicitly
            \item[propositional vs. relational] $\approx$ in tabular form vs. as a graph
        \end{description}

        \vfill

        \item One powerful tool:
        %
        \begin{description}\small
            \item[resolution] --- allowing for \alert{intensional} representations, programming, reasoning, \ldots
        \end{description}

        \vfill

        \item[$\rightarrow$] Two fundamental mechanisms for manipulating knowledge:
        %
        \begin{description}\small
            \item[substitution application] $\approx$ rewriting a formula by assigning variables
            \item[most general unifier] $\approx$ computing the substitution making 2 formul\ae{} equal
        \end{description}
    \end{itemize}
\end{frame}

%===============================================================================
\section{Resolution}
%===============================================================================

\begin{frame}{Overview}
    \begin{itemize}
        \item[$\checkmark$] Three main ingredients:
        %
        \begin{description}\small
            \item[terms] --- for representing entities
            \item[predicates] --- for representing statements about entities
            \item[clauses] --- for representing properties of entities or relations among them
        \end{description}

        \vfill

        \item[$\checkmark$] Many ways of representing knowledge through them:
        %
        \begin{description}\small
            \item[extensional vs. intensional] $\approx$ explicitly vs. implicitly
            \item[propositional vs. relational] $\approx$ in tabular form vs. as a graph
        \end{description}

        \vfill

        \item[$\rightarrow$] One powerful tool:
        %
        \begin{description}\small
            \item[resolution] --- allowing for \alert{intensional} representations, programming, reasoning, \ldots
        \end{description}

        \vfill

        \item[$\checkmark$] Two fundamental mechanisms for manipulating knowledge:
        %
        \begin{description}\small
            \item[substitution application] $\approx$ rewriting a formula by assigning variables
            \item[most general unifier] $\approx$ computing the substitution making 2 formul\ae{} equal
        \end{description}
    \end{itemize}
\end{frame}

%===============================================================================
\section{Demos}
%===============================================================================

\startDemo

\begin{frame}{\currentDemo{} -- First Demo}
	\begin{block}{Goal}
		Goal here
	\end{block}
	%
	\begin{itemize}
		\item further info here
	\end{itemize}
\end{frame}

%===============================================================================
\section{Exercises}
%===============================================================================

\startExercise

\begin{frame}{\currentExercise{} -- First Exercise}
	\begin{block}{Goal}
		Goal here
	\end{block}
	%
	\begin{itemize}
		\item further info here
	\end{itemize}
\end{frame}

%===============================================================================
\section*{}
%===============================================================================

%/////////
\frame{\titlepage}
%/////////

%===============================================================================
\section*{\refname}
%===============================================================================

%%%%
\setbeamertemplate{page number in head/foot}{}
%/////////
\begin{frame}[c,noframenumbering]{\refname}
%\begin{frame}[t,allowframebreaks,noframenumbering]{\refname}
%	\tiny
	\scriptsize
%	\footnotesize
	\bibliographystyle{apalike-AMS}
	\bibliography{ise-lab-inference}
\end{frame}
%/////////

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
